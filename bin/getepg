#!/usr/bin/python2
from socket import *
import threading  
import time
import traceback
import xml.sax
import xml.sax.handler
from xml.sax.saxutils import XMLGenerator
import sqlite3
import os
import os.path
import sys
import logging
import logging.handlers
import sys
import os.path
import optparse

sys.path.insert(0, os.path.join(
                     os.path.dirname(
                       os.path.dirname(
                         os.path.abspath(__file__))), "src")) 

from dvbstreamer.session import Session
from dvbstreamer import events

# Maximum number of seconds to wait for lock
TUNING_TIMEOUT = 60
# Maximum number of seconds to wait for the start of EPG tables.
EPG_TABLE_WAIT_TIME = 60
# Maximum number of seconds to wait before deciding we have had all the EPG tables.
EPG_TABLE_TIMEOUT = 30

log=logging.getLogger("cristel")

class EPGDatabase:
    EVENTS_TABLE = 'Events'
    EVENTS_COLUMN_SOURCE= 'source'
    EVENTS_COLUMN_EVENT = 'event'
    EVENTS_COLUMN_START = 'start'
    EVENTS_COLUMN_END   = 'end'
    EVENTS_COLUMN_CA    = 'ca'
    EVENTS_COLUMNS = [EVENTS_COLUMN_SOURCE , EVENTS_COLUMN_EVENT, 
                        EVENTS_COLUMN_START  , EVENTS_COLUMN_END  , EVENTS_COLUMN_CA]
    
    RATINGS_TABLE = 'Ratings'
    RATINGS_COLUMN_SOURCE = 'source'
    RATINGS_COLUMN_EVENT  = 'event'
    RATINGS_COLUMN_SYSTEM = 'system'
    RATINGS_COLUMN_VALUE  = 'value'
    RATINGS_COLUMNS = [RATINGS_COLUMN_SOURCE, RATINGS_COLUMN_EVENT, RATINGS_COLUMN_SYSTEM, RATINGS_COLUMN_VALUE]
    
    DETAILS_TABLE = 'Details'
    DETAILS_COLUMN_SOURCE = 'source'
    DETAILS_COLUMN_EVENT  = 'event'
    DETAILS_COLUMN_NAME   = 'name'
    DETAILS_COLUMN_LANG   = 'lang'
    DETAILS_COLUMN_VALUE  = 'value'
    DETAILS_COLUMNS = [DETAILS_COLUMN_SOURCE, DETAILS_COLUMN_EVENT, DETAILS_COLUMN_NAME, 
                        DETAILS_COLUMN_LANG, DETAILS_COLUMN_VALUE]
    
    def __init__(self, updater=False, reaper=False):
        self.dbpath = os.path.join(app_dir, 'database.db')
        self.create_tables()
        
        self.connections = {}
        
        self.message_q = []
        self.message_event = threading.Event()
        self.__quit = False
        if updater:
            self.updater_thread = threading.Thread(target=self.updater)
            self.updater_thread.setName('EPGDbase Updater')
            self.updater_thread.start()
        else:
            self.updater_thread = None

        if reaper:
            self.reaper_thread = threading.Thread(target=self.reaper)
            self.reaper_thread.setDaemon(True)
            self.reaper_thread.setName('EPGDbase Reaper')
            self.reaper_thread.start()
        
    def close(self):
        if self.updater_thread:
            self.__quit = True
            self.post_message(('quit',))
            self.updater_thread.join()
        
    def create_tables(self):
        connection = sqlite3.Connection(self.dbpath)
        cursor = connection.cursor()
        
        self.create_table(cursor, EPGDatabase.EVENTS_TABLE,  EPGDatabase.EVENTS_COLUMNS, 
                            [EPGDatabase.EVENTS_COLUMN_SOURCE, EPGDatabase.EVENTS_COLUMN_EVENT])
                              
        self.create_table(cursor, EPGDatabase.RATINGS_TABLE, EPGDatabase.RATINGS_COLUMNS, 
                            [EPGDatabase.RATINGS_COLUMN_SOURCE, EPGDatabase.RATINGS_COLUMN_EVENT,
                                EPGDatabase.RATINGS_COLUMN_SYSTEM])
        
        self.create_table(cursor, EPGDatabase.DETAILS_TABLE, EPGDatabase.DETAILS_COLUMNS, 
                            [EPGDatabase.DETAILS_COLUMN_SOURCE, EPGDatabase.DETAILS_COLUMN_EVENT,
                                EPGDatabase.DETAILS_COLUMN_NAME, EPGDatabase. DETAILS_COLUMN_LANG])
        connection.close()
        
    
    def create_table(self, cursor, table, fields, primary_key):
        sql = 'CREATE TABLE IF NOT EXISTS ' + table + '('
        for field in fields:
            sql += field + ','
        sql += 'PRIMARY KEY('
        for field in primary_key:
            sql += field + ','
        sql =sql[:-1] + '));'
        
        cursor.execute(sql)
    
    def get_connection(self):
        thread = threading.currentThread()
        if thread in self.connections:
            return self.connections[thread]
        connection = sqlite3.Connection(self.dbpath)
        self.connections[thread] = connection
        return connection
        
    def close_connection(self):
        thread = threading.currentThread()
        if thread in self.connections:
            self.connections[thread].close()
            del self.connections[thread]
        
    def get_events(self, source):
        connection = self.get_connection()
        cursor = connection.cursor()
        cursor.execute('SELECT %s FROM %s WHERE %s=?;' % (reduce(lambda x,y: x +','+y,EPGDatabase.EVENTS_COLUMNS), 
                                                         EPGDatabase.EVENTS_TABLE, 
                                                         EPGDatabase.EVENTS_COLUMN_SOURCE), (source,))
        return cursor.fetchall()
    
    def get_details(self, source, event):
        connection = self.get_connection()
        cursor = connection.cursor()
        cursor.execute('SELECT %s,%s,%s FROM %s WHERE %s=? AND %s=?;' % (EPGDatabase.DETAILS_COLUMN_NAME, 
                                                         EPGDatabase.DETAILS_COLUMN_LANG,
                                                         EPGDatabase.DETAILS_COLUMN_VALUE, 
                                                         EPGDatabase.DETAILS_TABLE, 
                                                         EPGDatabase.DETAILS_COLUMN_SOURCE,
                                                         EPGDatabase.DETAILS_COLUMN_EVENT), (source, event))
        details = {}
        for name,lang,value in cursor:
            if name in details:
                details[name].append((lang, value))
            else:
                details[name] = [(lang, value)]
        
        return details
    
    def get_ratings(self, source, event):
        connection = self.get_connection()
        cursor = connection.cursor()
        cursor.execute('SELECT %s,%s FROM %s WHERE %s=? AND %s=?;' % (EPGDatabase.RATINGS_COLUMN_SYSTEM,
                                                         EPGDatabase.RATINGS_COLUMN_VALUE,
                                                         EPGDatabase.RATINGS_TABLE, 
                                                         EPGDatabase.RATINGS_COLUMN_SOURCE,
                                                         EPGDatabase.RATINGS_COLUMN_EVENT), (source, event))
        return cursor.fetchall()
        
        
    def new_event(self, event_ref, start, end, ca):    
        self.post_message(('new', event_ref, start, end, ca))
        
    def __new_event(self, event_ref, start, end, ca):
        if 'TZ' in os.environ:
            tz = os.environ['TZ']
        else:
            tz = None
            
        os.environ['TZ']='UTC0'
        time.tzset()
        start_secs = int(time.mktime(start))
        end_secs = int(time.mktime(end))
        
        if tz is not None:
            os.environ['TZ'] = tz
            
        time.tzset()
        self.__update(EPGDatabase.EVENTS_TABLE, EPGDatabase.EVENTS_COLUMNS,
                        ('%04x.%04x.%04x' % event_ref[:3], event_ref[3], start_secs, end_secs, ca))
        
    
    def update_detail(self, event_ref, name, lang, value):
        self.post_message(('detail', event_ref, name, lang, value))
    
    def __update_detail(self, event_ref, name, lang, value):
        self.__update(EPGDatabase.DETAILS_TABLE, EPGDatabase.DETAILS_COLUMNS,
                        ('%04x.%04x.%04x' % event_ref[:3], event_ref[3], name, lang, value))
    
    def update_rating(self, event_ref, system, value):
        self.post_message(('rating', event_ref, system, value))
        
    def __update_rating(self, event_ref, system, value):
        self.__update(EPGDatabase.RATINGS_TABLE, EPGDatabase.RATINGS_COLUMNS,
                        ('%04x.%04x.%04x' % event_ref[:3], event_ref[3], system, value))
    
    def __update(self, table, columns, values):
        connection = self.get_connection()
        cursor = connection.cursor()
        sql = 'INSERT OR REPLACE INTO %s ( %s) VALUES (%s);' % (table, 
                                                                reduce(lambda x,y: x +','+y, columns),
                                                                reduce(lambda x,y: x.startswith('?') and x +',?' or '?,?', values))
        cursor.execute(sql, values)
        
    def post_message(self, msg):
        self.message_q.append(msg)
        self.message_event.set()
        
    def updater(self):
        connection = self.get_connection()
        updates = 0
        while not self.__quit:
            if len(self.message_q) == 0:
                self.message_event.wait()
                
            if len(self.message_q) > 0:
                msg = self.message_q.pop()
                if msg[0] == 'commit':
                    connection.commit()
                    updates = 0
                    
                elif msg[0] == 'new':
                    updates += 1
                    self.__new_event(*msg[1:])
                    
                elif msg[0] == 'detail':
                    updates += 1
                    self.__update_detail(*msg[1:])
                    
                elif msg[0] == 'rating':
                    updates += 1
                    self.__update_rating(*msg[1:])
                    
                elif msg[0] == 'reap':
                    updates = 0
                    self.__reap()
                    
                elif msg[0] == 'quit':
                    connection.commit()
                    
            if len(self.message_q) == 0:
                self.message_event.clear()
            

    def reaper(self):
        last_reap = 0.0
        while not self.__quit:
            now = time.time()
            if (now - last_reap) > 360.0:
                # Reap old events
                self.post_message(('reap',))
                last_reap = now
            else:
                self.post_message(('commit',))
            # Sleep for 30 seconds
            time.sleep(30.0)

    def __reap(self):
        connection = self.get_connection()
        cursor = connection.cursor()
        past24 = int(time.time() - (24.0 * 360.0))
        cursor.execute('DELETE FROM Events WHERE end<=?;',(past24,))
        # Remove orphaned details and ratings
        cursor.execute('DELETE FROM Details WHERE NOT EXISTS ' +
                        '(SELECT * FROM Events WHERE source=Details.source AND event=Details.event);')

        cursor.execute('DELETE FROM Ratings WHERE NOT EXISTS '+ 
                        '(SELECT * FROM Events WHERE source=Ratings.source AND event=Ratings.event);')

class EPGHandler:
    def __init__(self, session, db):
        self.session = session
        self.conn = session.get_epg_connection(self)
        self.db = db
        self.last_updated_time = 0
        self.muxes = []
        self.locked = False
        self.state = None
        self.last_state = None
        session.register_event_listener(events.LOCKED, self.adapter_locked)
        session.register_event_listener(events.UNLOCKED, self.adapter_unlocked)
        session.start_epg_capture()

    def stop(self):
        self.session.unregister_event_listener(events.LOCKED, self.adapter_locked)
        self.session.unregister_event_listener(events.UNLOCKED, self.adapter_unlocked)
        self.conn.stop()
        self.session.stop_epg_capture()
        self.session.close()

    def new_event(self, event_ref, start_time, end_time, is_ca):
        self.state = 'processing'
        self.db.new_event(event_ref, start_time, end_time, is_ca)
        self.last_updated_time = time.time()

    def update_rating(self, event_ref, rating_system, value):
        self.state = 'processing'
        self.db.update_rating(event_ref, rating_system, value)
        self.last_updated_time = time.time()

    def update_detail(self, event_ref, detail_name, detail_lang, detail_content):
        self.state = 'processing'
        self.db.update_detail(event_ref, detail_name, detail_lang, detail_content)
        self.last_updated_time = time.time()

    def select_next_mux(self):
        if not self.muxes:
            return None
        mux_id = self.muxes.pop()
        services = self.session.get_services(mux_id)
        self.session.select_service(services[0])
        self.last_updated_time = time.time()
        self.state = 'tuning'
        return mux_id

    def timedout(self):
        if self.state != self.last_state:
            print '%s:%d State: %s' % (self.session.host, self.session.adapter, self.state)
            self.last_state = self.state
        timediff = time.time() - self.last_updated_time
        if self.state == 'tuning':
            return  timediff > TUNING_TIMEOUT
        if self.state == 'waiting':
            return timediff > EPG_TABLE_WAIT_TIME
        return timediff > EPG_TABLE_TIMEOUT



    def adapter_locked(self, session, event):
        self.last_updated_time = time.time()
        self.locked = True
        self.state = 'waiting'

    def adapter_unlocked(self, session,  event):
        self.last_updated_time = time.time()
        self.locked = False
        


def usage():
    print '%s -c' % sys.argv[0]
    print 'Connects to one or more DVBStreamer daemons, specified in .epgdb/adapters, to process and store EPG data.'
    
    print 
    
    print '%s -x <outputfile>' % sys.argv[0]
    print 'Exports the database as an XMLTV file (<outputfile>) by connecting to the DVBStreamer daemons used to capture the data to find available services/channels'
    print 
    print 'Format of .epgdb/adapters file'
    print '------------------------------'
    print 'One DVBStreamer host/adapter specified per line in the following format:'
    print '<host>[:adapter[:<username>[:<password>]]]'
    print
    print 'host     - Either an IP address of hostname'
    print 'adapter  - The adapter number used by the DVBStreamer daemon (Default:0)'
    print 'username - Username used to authenitcate with the DVBStreamer daemon (Default:dvbstreamer)'
    print 'password - Password used to authenitcate with the DVBStreamer daemon (Default:control)'
    sys.exit(1)

    
def process_host(host):
    if host[0] == '[':
        # IPv6
        i = host.find(']')
        hostname = host[:i + 1]
        if len(host) > i + 1:
            rest = host[i + 2:]
        else:
            rest = ''
    else:
        tmp = host.find(':')
        if tmp == -1:
            rest = ''
            hostname = host
        else:
            rest =  host[tmp + 1:]
            hostname = host[:tmp]
    
    username = 'dvbstreamer'
    password = 'control'
    
    if rest:
        parts = rest.split(':')
        adapter = int(parts[0])
        if len(parts) > 1:
            username = parts[1]
        if len(parts) > 2:
            password = parts[2]
    else:
        adapter = 0
    return (hostname, adapter, username, password)

def capture_trickle():
    dbase = EPGDatabase(True, True)
    handlers = []

    for adapter in get_adapters():
        handlers.append(EPGHandler(Session(*adapter), dbase))


    try:
        while True:
            time.sleep(1.0)
    except KeyboardInterrupt:
        pass
    except:
        traceback.print_exc()

        
    for handler in handlers:
        handler.close()
    dbase.close()

def capture_full():
    dbase = EPGDatabase(True, True)

    handlers = []
    muxes_to_handlers = {}
    
    for adapter in get_adapters():
        session = Session(*adapter)
        muxes = session.get_multiplexes()
        epghandler = EPGHandler(session, dbase)
        for mux in muxes:
            if mux.dvb_id in muxes_to_handlers:
                muxes_to_handlers[mux.dvb_id].append(epghandler)
            else:
                muxes_to_handlers[mux.dvb_id] = [epghandler]
            epghandler.muxes.append(mux.dvb_id)
            
        handlers.append(epghandler)
    log.info('%d multiplexes to update' % len(muxes_to_handlers))
    count = 0
    while handlers:
        new_handlers = []
        for epghandler in handlers:
            if epghandler.timedout():
                # Move on to the next mux
                mux = epghandler.select_next_mux()

                if mux:
                    count += 1
                    log.info('%s:%d (%d) processing %s' % (epghandler.session.host, epghandler.session.adapter, count, mux))
                    for other_handler in muxes_to_handlers[mux]:
                        if mux in other_handler.muxes:
                            other_handler.muxes.remove(mux)
                else:
                    log.info('%s:%d finished' % (epghandler.session.host, epghandler.session.adapter))
                    epghandler.stop()
                    continue
            
            new_handlers.append(epghandler)

                    
        handlers = new_handlers
        try:
            time.sleep(1.0)
        except KeyboardInterrupt:
            break
        except:
            traceback.print_exc()
            break
    log.info('Finished updates')
    dbase.close()


def get_services_info(services, adapter):
    connection = Session(*adapter)
    try:        
        for service in connection.get_services():
            info = connection.get_service_info(service.dvb_id)
            net,ts,x = service.dvb_id.split('.')
            services[service.dvb_id] = (info.name, '%s.%s.%04x' % (net, ts, info.source))
        
        connection.close()
    except:
        traceback.print_exc()
        
def format_time(secs):
    return time.strftime('%Y%m%d%H%M%S +0000', time.gmtime(secs))

def export_xmltv(filename):
   
    dbase = EPGDatabase()
    outfilename = filename
    services = {}
    for adapter in get_adapters():
        get_services_info(services, adapter)
    
    outfile = open(outfilename, 'w')
    generator = XMLGenerator(outfile, 'UTF-8')
    generator.startDocument()
    generator.startElement('tv', {})
    
    # Channels
    for id,(name, source) in services.items():
        generator.startElement('channel', {'id':id})
        generator.startElement('display-name', {})
        generator.characters(name)
        generator.endElement('display-name')
        generator.endElement('channel')
    
    # Programmes
    for id,(name, source) in services.items():
        for event in dbase.get_events(source):
            start = format_time(event[2])
            stop  = format_time(event[3])
            
            generator.startElement('programme', {'start':start, 'stop':stop, 'channel':id})
            
            details = dbase.get_details(source, event[1])
            if 'title' in details:
                for lang,value in details['title']:
                    generator.startElement('title', {'lang':lang})
                    generator.characters(value)
                    generator.endElement('title')
            
            if 'description' in details:
                for lang,value in details['description']:
                    generator.startElement('desc', {'lang':lang})
                    generator.characters(value)
                    generator.endElement('desc')
            
            if 'content' in details:
                content = details['content'][0][1]
                generator.startElement('content', {})
                generator.characters(content)
                generator.endElement('content')
            
            if 'series' in details:
                series = details['series'][0][1]
                generator.startElement('series', {})
                generator.characters(series)
                generator.endElement('series')
            
            ratings = dbase.get_ratings(source, event[1])
            for system,value in ratings:
                generator.startElement('rating', {'system':system})
                generator.startElement('value', {})
                generator.characters(value)
                generator.endElement('value')
                generator.endElement('rating')
            generator.endElement('programme')
        
    generator.endElement('tv')
    generator.endDocument()
    outfile.close()
    
    
def get_adapters():
    adapters = []
    try:
        adaptersfile = open(os.path.join(app_dir, 'adapters'), 'r')
        for line in adaptersfile:
            line = line.strip()
            if line:
                adapters.append(process_host(line))
        adaptersfile.close()
    except:
        traceback.print_exc()
        log.info('WARNING: Failed to open adapters file, defaulting to localhost:0:dvbstreamer:control')
    if len(adapters) == 0:
        adapters = [('localhost', 0, 'dvbstreamer', 'control')]
    return adapters
    
# Location of the user data for epgdb    
app_dir = ''

def main():
    global app_dir

    log.setLevel(logging.INFO)
    handler=logging.handlers.SysLogHandler(address = '/dev/log', facility=logging.handlers.SysLogHandler.LOG_DAEMON)
    log.addHandler(handler)

    app_dir = os.path.expanduser('~/.epgdb')

    parser = optparse.OptionParser()
    parser.add_option('-t', '--trikle-fill', dest='trikle', help='Connect to the adapters specified in the ~/.epgdb/adapters files and register for EPG data but don\'t actively retune to update the EPG', action="store_true")
    parser.add_option('-c', '--force-update', dest='forced', help='Connect to the adapters specified in the ~/.epgdb/adapters files and actively retune to update the EPG', action="store_true")
    parser.add_option('-x', '--export-xmltv', dest='xmltv_file', help='Export the EPG database to the specified file in xmltv format.')
    options,args = parser.parse_args()

    if not os.path.exists(app_dir):
        os.mkdir(app_dir)
        
    if len(sys.argv) < 2:
        usage()
        
    if options.trikle:
        # Trickle fill database
        capture_trickle()
        
    elif options.forced:
        # Force fill the database 
        capture_full()
    
    if options.xmltv_file:
        print "Exporting to %s..." % options.xmltv_file,
        export_xmltv(options.xmltv_file)
        print "Done"
    

if __name__ == '__main__':
    try:
        main()
    except SystemExit:
        raise
    except:
        traceback.print_exc()
    sys.exit(0)
